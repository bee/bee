#!/bin/bash
#
# bee-check - check consistancy of installed bee-pkgs
#
# Copyright (C) 2009-2011
#       Marius Tolzmann <tolzmann@molgen.mpg.de>
#       Tobias Dreyer <dreyer@molgen.mpg.de>
#       and other bee developers
#
# This file is part of bee.
#
# bee is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

BEESEP=@BINDIR@/beesep

###############################################################################
###############################################################################
###############################################################################

if [ -z "${BEE_VERSION}" ] ; then
    echo >&2 "BEE-ERROR: please call $0 from bee .."
    exit 1
fi

VERSION=${BEE_VERSION}

###############################################################################
##
##
pkg_check_all() {

    if [ ! "${1}" ] ; then
        pkg_check
        return
    fi

    for pkg in ${@} ; do
        pkg_check ${pkg}
    done
}


###############################################################################
##
##
pkg_check_deps() {
    installed=$(${BEE_LIBEXECDIR}/bee/bee.d/bee-list --installed --exact ${1})

    if [ ! "${installed}" -a $OPT_F -gt 0 ] ; then
        installed=$(${BEE_LIBEXECDIR}/bee/bee.d/bee-list --installed "${1}")
    fi

    if [ "${installed}" ] ; then
        for i in ${installed} ; do
            do_check_deps "${i}"
        done
    fi
    exit 0
}

###############################################################################
##
##
pkg_check() {
    installed=$(${BEE_LIBEXECDIR}/bee/bee.d/bee-list --installed --exact ${1})

    if [ ! "${installed}" -a $OPT_F -gt 0 ] ; then
        installed=$(${BEE_LIBEXECDIR}/bee/bee.d/bee-list --installed "${1}")
    fi

    if [ "${installed}" ] ; then
        for i in ${installed} ; do
            do_check "${i}"
        done
        return 0
    fi

    installed=$(${BEE_LIBEXECDIR}/bee/bee.d/bee-list --installed "${1}")

    if [ "${installed}" ] ; then
        echo "packages matching '${1}':"
        for i in ${installed} ; do
            echo " [*] ${i}"
        done
    fi


}

do_check_deps_of_file() {
    local file=${1}
    local type="OTHER"

    local filetype=$(file ${file})

    case "${filetype}" in
        *"ar archive"*)
            type="AR"
            ;;

        *"ELF 64-bit LSB executable, x86-64"*)
            type="ELF64EXE"
            ;;

        *"ELF 64-bit LSB shared object, x86-64"*)
            type="ELF64SO"
            ;;

        *"ELF 32-bit LSB executable"*)
            type="ELF32EXE"
            ;;

        *"ELF 32-bit LSB shared object"*)
            type="ELF32SO"
            ;;

        *"script text executable"*)
            type="SCRIPT"
            ;;

        *"directory"*)
            type="DIRECTORY"
            ;;

        *"symbolic link"*)
            type="SYMLINK"
            ;;

        *)
            #echo >&2 "WARNING: unknown file type '${filetype#*: }'"
    esac

    echo "    type     = ${type^^}"
    # self provide basename seems not to be a good idea without
    # defining
#    echo "    provides = ${file##*/}"

    if [ "${type:0:3}" = "ELF" ] ; then
        readelf -d ${file} 2>/dev/null \
            | egrep "(NEEDED|SONAME)" \
            | sed -e 's,.*Shared library: \[\(.*\)\].*,    needs    = \1,' \
                  -e 's,.*Library soname: \[\(.*\)\].*,    provides = \1,'
    fi

    if [ "${type}" = "SCRIPT" ] ; then
        subtype=$(grep '#!' "${file}")
        subtype=( ${subtype:2} )

        for i in "${subtype[@]}" ; do
            if [ "${i:0:1}" = "/" ] ; then
                echo "    needs    = $i"
            fi
        done
    fi
}

###############################################################################
##
##
do_check_deps() {
    local pkg=${1}
    local filesfile=${BEE_METADIR}/${pkg}/FILES

    echo -e "[${pkg}]"

    eval $(@BINDIR@/beeversion "${pkg}")

    echo "    type     = PACKAGE"
    echo "    provides = ${PKGNAME}"
    echo "    provides = ${PKGFULLPKG}"

    for line in $(cat ${filesfile}) ; do
        eval $(${BEESEP} ${line})
        echo "    provides = ${file%%//*}"
    done

    for line in $(cat ${filesfile}) ; do
        eval $(${BEESEP} ${line})

        # save and strip possible symbolic link destination..
        symlink=${file#*//}
        file=${file%%//*}

        echo -e "\n[${file}]"

        echo "    mode     = ${mode}"
        echo "    nlink    = ${nlink}"
        echo "    uid      = ${uid}"
        echo "    gid      = ${gid}"
        echo "    size     = ${size}"
        echo "    mtime    = ${mtime}"

        if [ "${md5}" = "link" ] ; then
            echo "    symlink  = ${symlink}"
        elif [ "${md5}" != "directory" ] ; then
            echo "    md5      = ${md5}"
        fi

        do_check_deps_of_file "${file}"

    done
}

###############################################################################
##
##
do_check() {
    local pkg=${1}

    local filesfile=${BEE_METADIR}/${pkg}/FILES

    echo "checking ${pkg} .."

    for line in $(cat ${filesfile}) ; do
        eval $(${BEESEP} ${line})

        # save and strip possible symbolic link destination..
        symlink=${file#*//}
        file=${file%%//*}

        if [ ! -e "${file}" ] && [ ! -h "${file}" ]; then
            echo "  [missing] <${md5}> ${file}"
            continue
        fi

        if [ "${md5}" = "link" ] ; then
            if [ ! -h "${file}" ] ; then
                echo "  [changed] <was symlink to ${symlink}> ${file}"
            else
                sdest=$(readlink ${file})
                if [ "${sdest}"  != "${symlink}" ] ; then
                    echo "  [changed] <symlink desitination '${symlink}' != '${sdest}'> ${file}"
                fi
                #echo "  [ DEBUG ] <OK> ${file} -> ${symlink}"
            fi
            continue
        fi

        if [ "${md5}" = "directory" ] ; then
            if [ ! -d "${file}" ] ; then
                echo "  [changed] <was directory> ${file}"
            fi
            continue
        fi

        # regular file - check md5sum..

        md5now=$(md5sum ${file} | sed -e 's,^\([a-z0-9]*\).*$,\1,')

        if [ "${md5}" != "${md5now}" ] ; then
            echo "  [changed] <${md5} != ${md5now}> ${file}"
            continue
        fi
    done

}

##### usage ###################################################################
usage() {
    cat <<-EOF
	bee-check v${VERSION} 2009-2011
	  by Marius Tolzmann and Tobias Dreyer <{tolzmann,dreyer}@molgen.mpg.de>
	     Max Planck Institute for Molecular Genetics Berlin Dahlem

	Usage: bee check [options] [action] <package>

	Actions:
	    -d | --deps       print dependencies of the package
	    -h | --help       display this help

	Options:
	    -f | --force      can be used to force check come what may
	    -v | --verbose    bee more verbose (can be used twice e.g. -vv)

	EOF
}

###############################################################################
##
##
options=$(getopt -n bee_check \
                 -o advfh \
                 --long verbose,all,force,help,deps \
                 -- "$@")
if [ $? != 0 ] ; then
  usage
  exit 1
fi
eval set -- "${options}"

declare -i OPT_A=0
declare -i OPT_F=0

while true ; do
  case "$1" in
    -a|--all|-v|--verbose)
      shift;
      OPT_A=$OPT_A+1
      ;;
    -f|--force)
      shift;
      OPT_F=$OPT_F+1
      ;;
    -d|--deps)
      shift 2;
      pkg_check_deps ${@}
      exit 0
      ;;
    -h|--help)
      usage
      exit 0
    ;;
    *)
      shift
      pkg_check_all ${@}
      exit 0;
      ;;
  esac
done
